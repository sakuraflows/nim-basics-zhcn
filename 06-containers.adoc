= 容器 Containers



容器是一种数据类型，它包含一组元素并允许我们访问这些元素。通常容器也是可迭代的，这意味着我们可以像在<<循环 Loops, 循环 Loops>>中使用字符串那样使用它们。

例如，购物清单是我们想购买的物品的容器，而质数列表则是数字的容器。用伪代码表示：
[source]
----
groceryList = [ham, eggs, bread, apples]
primes = [1, 2, 3, 5, 7]
----



== 数组 Arrays

数组是最简单的容器类型。数组是同质的，即数组中的所有元素必须具有相同的类型。数组的大小也是固定的，意味着元素的数量（或者更准确地说：可能的元素数量）必须在编译时已知。这意味着我们称数组为“固定长度的同质容器”。

数组类型使用 `array[<length>, <type>]` 声明，其中 `length` 是数组的总容量（可容纳的元素数量）， `type` 是其所有元素的类型。如果长度和类型可以从传递的元素中推断出来，则可以省略声明。

数组的元素被包含在方括号内。
[source]
----
var
  a: array[3, int] = [5, 7, 9]
  b = [5, 7, 9]        <1>
  c = []  # error      <2>
  d: array[7, string]  <3>
----
<1> 如果我们提供了值，数组 `b` 的长度和类型在编译时就是已知的。虽然正确，但无需像数组 `a` 那样特别声明。
<2> 这种声明方式既无法推断元素的长度，也无法推断其类型——这会导致错误。
<3> 正确声明空数组（稍后将填充）的方法是给出其长度和类型，而不提供元素值——数组 `d` 可以包含七个字符串。


由于数组的长度必须在编译时已知，因此以下代码将无法工作：

[source]
----
const m = 3
let n = 5

var a: array[m, char]
var b: array[n, char] # error <1>
----
<1> 这会产生错误，因为 `n` 是用 `let` 声明的——它的值在编译时是未知的。我们只能使用用 `const` 声明的值作为数组初始化的 `length` 参数。





== 序列 Sequences

序列（Sequences）是一种类似于数组的容器，但其长度无需在编译时已知，且可在运行时动态变化：我们仅需通过 `seq[<type>]` 声明所包含元素的类型。序列也是同质的（homogeneous），即序列中的每个元素必须具有相同的类型。

序列的元素被包含在 `@[` 和 `]` 之间。

[source]
----
var
  e1: seq[int] = @[]   <1>
  f = @["abc", "def"]  <2>
----
<1> 空序列的类型必须被声明。
<2> 非空序列的类型可以被推断出来。在这个例子中，它是一个包含字符串的序列。

另一种初始化空序列的方法是调用 `newSeq` 过程。我们将在<<过程 Procedures, 下一章节>>更详细地介绍过程调用，但现在只需知道这也是一种可行方式：

[source]
----
var
  e = newSeq[int]() <1>
----
<1> 在方括号内提供类型参数可以让过程知道它应该返回某种特定类型的序列。 +
一个常见的错误是遗漏了在末尾的 `()` ，这是必需的。


我们可以使用 `add` 函数向序列中添加新元素，这与处理字符串的方式类似。为此，序列必须是可变的（用 `var` 定义），并且我们添加的元素必须与序列中的元素类型相同。

[source]
.seq.nim
----
include::{source-dir}/seq.nim[]
----
<1> 添加一个相同类型（char）的新元素。
<2> 添加另一个包含相同类型的序列。

[source, output]
----
@['x', 'y', 'z']
@['1', '2', '3', 'x', 'y', 'z']
----

尝试将不同类型传递给现有序列会产生错误：

[source]
----
var i = @[9, 8, 7]

i.add(9.81) # error <1>
g.add(i)    # error <2>
----
<1> 尝试将 `float` 添加到 `int` 的序列中。
<2> 尝试将序列 `int` 添加到序列 `char` 中


由于序列长度可变，我们需要一种获取其长度的方法，为此可以使用 `len` 函数。

[source]
----
var i = @[9, 8, 7]
echo i.len

i.add(6)
echo i.len
----

[source, output]
----
3
4
----





== 索引 Indexing 与 切片 slicing

索引允许我们通过下标从容器中获取特定元素。
可以将索引视为容器内部的位置标识。

Nim与许多编程语言一样采用零基索引，即容器中第一个元素的索引为零，第二个元素的索引为一，以此类推。

若要从后向前索引，需使用 `^` 前缀。最后一个元素（即倒数第一个）的索引是 `^1` 。

索引的语法是 `<container>[<index>]` 。

[source]
.indexing.nim
----
include::{source-dir}/indexing.nim[lines=1..4]
----
<1> 零基索引：索引 `1` 对应的元素是 `b` 。
<2> 获取最后一个元素。

[source, output]
----
b
e
----

{nbsp}

切片操作允许我们通过一次调用获取一系列元素。它使用的语法与范围（在 <<for循环(For loop), for循环(For loop)>> 中介绍过）相同。


若使用 `start .. stop` 语法，切片范围包含两端。使用 `start ..< stop` 语法时， `stop` 索引不包含在切片内。

The syntax for slicing is `<container>[<start> .. <stop>]`.切片的语法是 `<container>[<start> .. <stop>]` 。

[source]
.indexing.nim
----
include::{source-dir}/indexing.nim[lines=6..8]
----

[source, output]
----
@[a, b, c, d]
@[a, b, c]
----


索引和切片均可用于为现有的可变容器和字符串赋予新值。

[source]
.assign.nim
----
include::{source-dir}/assign.nim[]
----
<1> 长度为 5 的数组索引从零到四。我们将为数组的每个元素赋值。
<2> 修改序列中第二个元素（索引为 1）的值。
<3> 修改字符串中索引为 8 和 9 位置的字符。


[source, output]
----
[0, 7, 14, 21, 28]
@['p', 'q', 'r']
Tom and Barry
----




== 元组 Tuples

我们目前所见到的容器都是同质的。
而元组则包含异质数据，即元组中的元素可以是不同类型。与数组类似，元组具有固定大小。

元组的元素被包裹在圆括号内。

[source]
.tuples.nim
----
include::{source-dir}/tuples.nim[lines=1..3]
----
<1> 元组可以包含不同类型的字段。在这个例子中： `string` 、 `int` 和 `char` 。

[source, output]
----
(Field0: "Banana", Field1: 2, Field2: 'c')
----



我们还可以为元组中的每个字段命名以便区分。这种方式可用于访问元组元素，而无需使用索引。

[source]
.tuples.nim
----
include::{source-dir}/tuples.nim[lines=5..10]
----
<1> 通过字段索引修改字段值
<2> 通过字段名称修改字段值

[source, output]
----
(name: "Apple", weight: 7, rating: 'c')
----





== 练习

1. 创建一个能容纳十个整数的空数组。
    * 用数字10、20、……、100填充该数组。（提示：使用循环）
    * 仅打印该数组中位于奇数索引的元素（即数值20、40、……）。
    * 将偶数索引位置的元素乘以 5。打印修改后的数组。

2. 重新实现考拉兹猜想（<<_练习_2, Collatz conjecture exercise>>）练习，但这次不打印每个步骤，而是将其添加到序列中。
    * 选择一个起始数字。有趣的选择包括9、19、25和27等。
    * 创建一个仅包含该起始数字的序列
    * 沿用之前的逻辑，持续向序列中添加元素，直到数值变为 1
    * 输出序列的长度及序列本身

3. 在2到100的范围内找出产生最长考拉兹序列的数字。
    * 对于给定范围内的每个数字，计算其考拉兹序列
    * 如果当前序列长度超过之前的记录，则将当前长度和起始数字保存为新记录（可以使用元组 `(longestLength, startingNumber)` 或两个单独的变量）
    * 输出起始数字及其对应序列的最大长度
